<!DOCTYPE html>
<html>
    <head>
    <title>Multi$nake</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'Monaco';
            src: url('https://cdn.jsdelivr.net/npm/@fontsource/monaco@4.5.1/files/monaco-normal-400.woff2') format('woff2');
        }
        canvas {
            border: 12px solid #FFA500; /* Orange-gold border */
            box-shadow: none;
            background-color: #f0f0f0;
            border-radius: 20px;
            /* Remove the outer gray frame */
            outline: none;
            outline-offset: 0;
            max-width: 100%;
            height: auto;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            background: linear-gradient(to bottom, #006400, #003000); /* Dark green gradient */
            position: relative;
            overflow: hidden;
            font-family: 'Nunito', sans-serif;
            animation: rotateGradient 30s linear infinite; /* Slow rotation */
            box-sizing: border-box;
        }
        
        /* Game container to handle responsive sizing */
        .game-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            position: relative;
            display: flex;
            justify-content: center;
        }
        
        /* Mobile controls */
        .mobile-controls {
            display: none; /* Hidden by default */
            width: 100%;
            max-width: 800px;
            margin-top: 20px;
            justify-content: space-between;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        /* Controller containers - NES style */
        .controller {
            background-color: rgba(50, 50, 50, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            position: relative;
            width: 45%;
            max-width: 180px;
        }
        
        .controller:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px 10px 0 0;
        }
        
        /* Player-specific controller styles */
        .red-player.controller {
            background: linear-gradient(to bottom, #400 0%, #300 100%);
            border: 2px solid #500;
        }
        
        .blue-player.controller {
            background: linear-gradient(to bottom, #004 0%, #003 100%);
            border: 2px solid #005;
        }
        
        /* Controller labels */
        .controller-label {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
            font-family: 'Nunito', sans-serif;
            color: white;
            text-shadow: 1px 1px 2px black;
            font-size: 14px;
        }
        
        /* D-pad container */
        .d-pad {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto;
        }
        
        /* Control button - make larger on mobile for easier tapping */
        .control-button {
            width: 40px;
            height: 40px;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            user-select: none;
            touch-action: manipulation;
            position: absolute;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.5);
            transition: transform 0.05s, background-color 0.05s;
            cursor: pointer; /* Add pointer cursor for buttons */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }
        
        /* Add active state for touch */
        .control-button.active {
            transform: scale(0.95) translateY(2px) !important;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        /* Position for d-pad buttons */
        .btn-up {
            top: 0;
            left: 40px;
        }
        
        .btn-right {
            top: 40px;
            right: 0;
        }
        
        .btn-down {
            bottom: 0;
            left: 40px;
        }
        
        .btn-left {
            top: 40px;
            left: 0;
        }
        
        /* Center button (non-functional, just for appearance) */
        .btn-center {
            top: 40px;
            left: 40px;
            width: 40px;
            height: 40px;
            background-color: #333;
            border-radius: 5px;
            position: absolute;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.8);
        }
        
        /* Red player center button */
        .red-player .btn-center {
            background-color: #400;
            border: 1px solid #500;
        }
        
        /* Blue player center button */
        .blue-player .btn-center {
            background-color: #004;
            border: 1px solid #005;
        }
        
        /* Red player buttons */
        .red-player .control-button {
            background: linear-gradient(to bottom, #c00 0%, #900 100%);
            border: 2px solid #b00;
            color: white;
        }
        
        .red-player .control-button:active {
            background: linear-gradient(to bottom, #f00 0%, #c00 100%);
            transform: scale(0.95);
        }
        
        /* Blue player buttons */
        .blue-player .control-button {
            background: linear-gradient(to bottom, #00c 0%, #009 100%);
            border: 2px solid #00b;
            color: white;
        }
        
        .blue-player .control-button:active {
            background: linear-gradient(to bottom, #00f 0%, #00c 100%);
            transform: scale(0.95);
        }
        
        /* Only show mobile controls on touch devices, not on desktop regardless of screen size */
        body.has-touch-support .mobile-controls {
            display: flex !important; /* Changed to flex to arrange controllers side by side */
        }
        
        @keyframes rotateGradient {
            0% {
                background: linear-gradient(0deg, #006400, #003000);
            }
            25% {
                background: linear-gradient(90deg, #006400, #003000);
            }
            50% {
                background: linear-gradient(180deg, #006400, #003000);
            }
            75% {
                background: linear-gradient(270deg, #006400, #003000);
            }
            100% {
                background: linear-gradient(360deg, #006400, #003000);
            }
        }
        
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(1px 1px at 10% 20%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 25% 45%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 40% 15%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 55% 70%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 70% 30%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 85% 60%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 15% 80%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 30% 35%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 65% 85%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px),
                radial-gradient(1px 1px at 90% 10%, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0) 1px);
            background-size: 300px 300px;
            pointer-events: none;
            z-index: -1;
            animation: starMove 20s linear infinite;
            will-change: transform; /* Hardware acceleration hint */
            backface-visibility: hidden; /* Reduce flicker on some mobile devices */
            -webkit-backface-visibility: hidden;
        }
        
        /* Create a second pseudo-element with different star positions for more depth */
        body::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(1.5px 1.5px at 15% 15%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0) 1.5px),
                radial-gradient(1.5px 1.5px at 35% 60%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0) 1.5px),
                radial-gradient(1.5px 1.5px at 50% 25%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0) 1.5px),
                radial-gradient(1.5px 1.5px at 65% 45%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0) 1.5px),
                radial-gradient(1.5px 1.5px at 80% 75%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0) 1.5px),
                radial-gradient(1.5px 1.5px at 95% 35%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0) 1.5px),
                radial-gradient(1.5px 1.5px at 20% 90%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0) 1.5px),
                radial-gradient(1.5px 1.5px at 45% 5%, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0) 1.5px);
            background-size: 350px 350px;
            pointer-events: none;
            z-index: -1;
            animation: starMoveAlt 25s linear infinite;
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        
        @keyframes starMove {
            0% {
                transform: translate(0, 0) rotate(0deg);
            }
            25% {
                transform: translate(-50px, -150px) rotate(0.5deg);
            }
            50% {
                transform: translate(25px, -300px) rotate(1deg);
            }
            75% {
                transform: translate(-25px, -150px) rotate(0.5deg);
            }
            100% {
                transform: translate(0, 0) rotate(0deg);
            }
        }
        
        @keyframes starMoveAlt {
            0% {
                transform: translate(0, 0) rotate(0deg);
            }
            25% {
                transform: translate(50px, -100px) rotate(-0.5deg);
            }
            50% {
                transform: translate(-35px, -250px) rotate(-1deg);
            }
            75% {
                transform: translate(35px, -125px) rotate(-0.5deg);
            }
            100% {
                transform: translate(0, 0) rotate(0deg);
            }
        }
        
        @keyframes textPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* Small stars that move quickly for more erratic background effect */
        .star-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -2;
            pointer-events: none;
        }
        
        .small-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            animation: smallStarMove linear infinite;
        }
        
        @keyframes smallStarMove {
            0% {
                transform: translate(0, 0);
            }
            100% {
                transform: translate(var(--end-x), var(--end-y));
            }
        }
        
        .score-container {
            position: absolute;
            width: 100%;
            pointer-events: none;
        }
        
        .score-text {
            font-weight: 900;
            animation: textPulse 3s ease-in-out infinite;
            display: inline-block;
            text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.8);
        }

        .death-message {
            font-family: 'Nunito', sans-serif;
            font-size: 32px;
            font-weight: bold;
            color: orange;
            text-align: center;
            margin-top: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 10;
            width: 100%;
        }
        
        /* Media queries for different orientations */
        @media (orientation: landscape) and (max-width: 900px) {
            body {
                flex-direction: row;
                padding: 5px;
            }
            
            .game-container {
                flex: 2;
                margin-right: 10px;
            }
            
            body.has-touch-support .mobile-controls {
                flex-direction: column;
                position: absolute;
                right: 20px;
                top: 50%;
                transform: translateY(-50%);
                width: auto;
                margin-top: 0;
                margin-right: 10px;
                height: 98vh;
                justify-content: space-evenly;
            }
            
            .controller {
                margin: 5px 0;
                width: 130px;
            }
            
            .d-pad {
                transform: scale(0.8);
            }
            
            .controller-label {
                font-size: 12px;
                margin-bottom: 5px;
            }
            
            .death-message {
                position: absolute;
                bottom: 10px;
                left: 0;
                right: 0;
            }
        }

        @media (orientation: portrait) {
            body {
                flex-direction: column;
                padding: 10px;
            }
            
            .game-container {
                width: 100%;
            }
            
            body.has-touch-support .mobile-controls {
                margin-top: 20px;
                flex-direction: row;
                justify-content: space-evenly;
                width: 100%;
            }
            
            .controller {
                margin: 0 5px;
            }
        }
        
        .back-button {
            position: fixed;
            top: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.7);
            color: #006400;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            text-decoration: none;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s, transform 0.2s;
        }
        
        .back-button:hover {
            background-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.05);
        }
    </style>
    </head>
    <body>
        <a href="/" class="back-button" title="Back to ScroggyGames.com">&#8592;</a>
        
        <div class="star-container"></div>
        <div class="game-container">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        <div id="deathMessage" class="death-message"></div>
        <div class="mobile-controls">
            <div class="control-row">
                <div class="controller red-player">
                    <div class="controller-label">Red Player</div>
                    <div class="d-pad">
                        <button class="control-button btn-up" id="red-up" data-direction="up1">↑</button>
                        <button class="control-button btn-left" id="red-left" data-direction="left1">←</button>
                        <button class="control-button btn-down" id="red-down" data-direction="down1">↓</button>
                        <button class="control-button btn-right" id="red-right" data-direction="right1">→</button>
                        <div class="btn-center"></div>
                    </div>
                </div>
                <div class="controller blue-player">
                    <div class="controller-label">Blue Player</div>
                    <div class="d-pad">
                        <button class="control-button btn-up" id="blue-up" data-direction="up2">↑</button>
                        <button class="control-button btn-left" id="blue-left" data-direction="left2">←</button>
                        <button class="control-button btn-down" id="blue-down" data-direction="down2">↓</button>
                        <button class="control-button btn-right" id="blue-right" data-direction="right2">→</button>
                        <div class="btn-center"></div>
                    </div>
                </div>
            </div>
        </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // For debugging - set to true to force display mobile controls on all devices (for testing)
        const FORCE_MOBILE_CONTROLS = false;

        // Player objects
        const player1 = {
            x: 100,
            y: 300,
            size: 20,
            speed: 3,
            color: 'red',
            body: [],
            maxLength: 100,
            direction: { x: 1, y: 0 }
        };

        const player2 = {
            x: 700,
            y: 300,
            size: 20,
            speed: 3,
            color: 'blue',
            body: [],
            maxLength: 100,
            direction: { x: -1, y: 0 }
        };

        // Add after canvas setup
        let hue = 0; // For rainbow effect
        const checkerSize = 50; // Size of checker squares

        // Add after the player objects
        const gameState = {
            gameOver: false,
            winner: null
        };

        // Add after the gameState object
        const scores = {
            red: 0,
            blue: 0
        };

        // Add after the scores object
        const bomb = {
            x: 0,
            y: 0,
            size: 25,
            active: false,
            explosionRadius: 50,
            explosionFrame: 0,
            exploding: false
        };

        // Add after the bomb object
        const victoryAnimation = {
            progress: 0,
            maxHeight: 300,
            speed: 2,
            angle: 15,
            topOffset: 150,
            bottomOffset: 150
        };

        function drawBackground() {
            // Update hue for rainbow effect
            hue = (hue + 0.5) % 360;
            
            // Draw rainbow checkerboard
            for (let x = 0; x < canvas.width; x += checkerSize) {
                for (let y = 0; y < canvas.height; y += checkerSize) {
                    // Use HSL for rainbow colors
                    ctx.fillStyle = `hsl(${hue}, 70%, ${((x + y) / checkerSize) % 2 === 0 ? 30 : 20}%)`;
                    ctx.fillRect(x, y, checkerSize, checkerSize);
                }
            }
        }

        function drawSnake(player) {
            // Draw body with enhanced 3D effect and rounded corners
            player.body.forEach((segment, index) => {
                const alpha = 0.3 + (0.7 * (index / player.body.length));
                const baseColor = player.color === 'red' ? [255, 0, 0] : [0, 0, 255];
                
                // Create 3D effect with multiple layers
                // Bottom shadow layer (much darker)
                ctx.fillStyle = `rgba(${baseColor[0] * 0.3}, ${baseColor[1] * 0.3}, ${baseColor[2] * 0.3}, ${alpha})`;
                ctx.beginPath();
                ctx.roundRect(segment.x + 6, segment.y + 6, player.size, player.size, player.size / 3);
                ctx.fill();
                
                // Middle layer (base color)
                ctx.fillStyle = `rgba(${baseColor[0]}, ${baseColor[1]}, ${baseColor[2]}, ${alpha})`;
                ctx.beginPath();
                ctx.roundRect(segment.x, segment.y, player.size, player.size, player.size / 3);
                ctx.fill();
                
                // Highlight layer (darker and lower down)
                ctx.fillStyle = `rgba(${Math.min(255, baseColor[0] + 80)}, ${Math.min(255, baseColor[1] + 80)}, ${Math.min(255, baseColor[2] + 80)}, ${alpha * 0.6})`;
                ctx.beginPath();
                ctx.roundRect(segment.x - 1, segment.y + 1, player.size * 0.5, player.size * 0.5, player.size / 5);
                ctx.fill();
            });
        }

        // Add a function to draw the scores
        function drawScores() {
            // Set up text styling
            ctx.font = 'bold 36px "Nunito", sans-serif';
            ctx.textAlign = 'center';
            
            // Add drop shadow effect
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            // Calculate scale factor for pulsing effect
            const pulseFactor = 1 + 0.1 * Math.sin(Date.now() / 1500);
            
            // Save context for scaling
            ctx.save();
            
            // Draw red score at the top with scaling
            ctx.translate(canvas.width / 2, 50);
            ctx.scale(pulseFactor, pulseFactor);
            ctx.translate(-canvas.width / 2, -50);
            
            // Draw text with frame color (orange)
            ctx.fillStyle = '#FFA500';
            ctx.fillText(`✨ Red Wins: ${scores.red}`, canvas.width / 2, 50);
            
            // Restore context
            ctx.restore();
            
            // Save context for blue score scaling
            ctx.save();
            
            // Draw blue score at the bottom with scaling (slightly out of phase)
            ctx.translate(canvas.width / 2, canvas.height - 30);
            ctx.scale(pulseFactor * 0.9, pulseFactor * 0.9); // Slightly different scale
            ctx.translate(-canvas.width / 2, -(canvas.height - 30));
            
            // Draw text with frame color (orange)
            ctx.fillStyle = '#FFA500';
            ctx.fillText(`✨ Blue Wins: ${scores.blue}`, canvas.width / 2, canvas.height - 30);
            
            // Restore context
            ctx.restore();
            
            // Reset shadow
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        // Add a function to place the bomb randomly
        function placeBomb() {
            bomb.x = Math.floor(Math.random() * (canvas.width - bomb.size * 2)) + bomb.size;
            bomb.y = Math.floor(Math.random() * (canvas.height - bomb.size * 2)) + bomb.size;
            bomb.active = true;
            bomb.exploding = false;
            bomb.explosionFrame = 0;
        }

        // Update the drawBomb function to make it cooler
        function drawBomb() {
            if (!bomb.active) return;
            
            if (bomb.exploding) {
                // Super simple explosion with 4 solid-colored circles that fade out
                const explosionSize = bomb.explosionRadius * (bomb.explosionFrame / 40);
                
                // Calculate fade-out opacity based on explosion progress
                const fadeOpacity = 1 - (bomb.explosionFrame / 40);
                
                // Draw 4 solid-colored circles with a red-to-yellow color scheme
                const colors = ['#FF0000', '#FF4500', '#FF8C00', '#FFD700']; // Red, Dark Orange, Orange, Yellow
                const circleCount = 4;
                
                for (let i = 0; i < circleCount; i++) {
                    const scale = 1 - (i * 0.25); // Evenly spaced sizes
                    const size = explosionSize * scale;
                    const color = colors[i];
                    
                    // Apply the fade-out effect to each circle
                    const rgba = hexToRgba(color, fadeOpacity);
                    ctx.fillStyle = rgba;
                    ctx.beginPath();
                    ctx.arc(
                        bomb.x + bomb.size/2, 
                        bomb.y + bomb.size/2, 
                        size, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                }
                
                bomb.explosionFrame++;
                if (bomb.explosionFrame > 40) {
                    bomb.active = false;
                    setTimeout(placeBomb, 2000); // Place a new bomb after 2 seconds
                }
            } else {
                // Enhanced bomb appearance
                const pulseAmount = Math.sin(Date.now() / 200) * 0.1;
                const bombSize = bomb.size * (1 + pulseAmount);
                
                // Save context for shadow
                ctx.save();
                
                // Add enhanced drop shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
                
                // Draw bomb body with metallic gradient
                const bombGradient = ctx.createRadialGradient(
                    bomb.x + bombSize/2 - bombSize/4, 
                    bomb.y + bombSize/2 - bombSize/4, 
                    0,
                    bomb.x + bombSize/2, 
                    bomb.y + bombSize/2, 
                    bombSize/2
                );
                bombGradient.addColorStop(0, '#444');
                bombGradient.addColorStop(0.5, '#111');
                bombGradient.addColorStop(0.8, '#000');
                bombGradient.addColorStop(1, '#222');
                
                ctx.fillStyle = bombGradient;
                ctx.beginPath();
                ctx.arc(bomb.x + bombSize/2, bomb.y + bombSize/2, bombSize/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Remove shadow for details
                ctx.restore();
                
                // Draw bomb cap (metallic)
                const capGradient = ctx.createRadialGradient(
                    bomb.x + bombSize/2 - bombSize/12, 
                    bomb.y + bombSize/4 - bombSize/12, 
                    0,
                    bomb.x + bombSize/2, 
                    bomb.y + bombSize/4, 
                    bombSize/6
                );
                capGradient.addColorStop(0, '#AAA');
                capGradient.addColorStop(0.5, '#777');
                capGradient.addColorStop(1, '#555');
                
                ctx.fillStyle = capGradient;
                ctx.beginPath();
                ctx.arc(bomb.x + bombSize/2, bomb.y + bombSize/4, bombSize/6, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw highlight on bomb
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(
                    bomb.x + bombSize/3, 
                    bomb.y + bombSize/3, 
                    bombSize/4, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Draw animated fuse with wave pattern
                ctx.strokeStyle = '#8B4513'; // Brown
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(bomb.x + bombSize/2, bomb.y + bombSize/4);
                
                // Create wavy fuse
                const fuseLength = bombSize;
                const segments = 10;
                const waveHeight = 5;
                const waveSpeed = Date.now() / 300;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = bomb.x + bomb.size/2 + t * fuseLength;
                    const y = bomb.y + bomb.size/4 - fuseLength/2 * t + 
                             Math.sin(t * Math.PI * 3 + waveSpeed) * waveHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw animated spark
                const sparkTime = Date.now() / 100;
                const sparkHue = (sparkTime % 60) + 10;
                const sparkSize = 3 + Math.sin(sparkTime) * 2;
                const sparkX = bomb.x + bomb.size/2 + fuseLength;
                const sparkY = bomb.y + bomb.size/4 - fuseLength/2 + 
                              Math.sin(Math.PI * 3 + waveSpeed) * waveHeight;
                
                // Draw multiple spark particles
                for (let i = 0; i < 5; i++) {
                    const particleAngle = Math.random() * Math.PI * 2;
                    const particleDistance = Math.random() * sparkSize * 1.5;
                    const particleX = sparkX + Math.cos(particleAngle) * particleDistance;
                    const particleY = sparkY + Math.sin(particleAngle) * particleDistance;
                    const particleSize = 1 + Math.random() * 2;
                    
                    ctx.fillStyle = `hsl(${sparkHue + i * 10}, 100%, ${50 + i * 10}%)`;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Add glow around spark
                const sparkGlow = ctx.createRadialGradient(
                    sparkX, sparkY, 0,
                    sparkX, sparkY, sparkSize * 3
                );
                sparkGlow.addColorStop(0, `hsla(${sparkHue}, 100%, 70%, 0.8)`);
                sparkGlow.addColorStop(0.5, `hsla(${sparkHue}, 100%, 60%, 0.4)`);
                sparkGlow.addColorStop(1, `hsla(${sparkHue}, 100%, 50%, 0)`);
                
                ctx.fillStyle = sparkGlow;
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, sparkSize * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Add warning pulsing glow around bomb
                const warningOpacity = 0.1 + Math.sin(Date.now() / 300) * 0.1;
                const warningGlow = ctx.createRadialGradient(
                    bomb.x + bombSize/2, bomb.y + bombSize/2, bombSize/2,
                    bomb.x + bombSize/2, bomb.y + bombSize/2, bombSize * 1.5
                );
                warningGlow.addColorStop(0, `rgba(255, 0, 0, ${warningOpacity})`);
                warningGlow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                ctx.fillStyle = warningGlow;
                ctx.beginPath();
                ctx.arc(bomb.x + bombSize/2, bomb.y + bombSize/2, bombSize * 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Add bomb collision check to the gameLoop
        function checkBombCollision() {
            if (!bomb.active || bomb.exploding) return false;
            
            // Check if player1 hit the bomb
            if (Math.abs(player1.x + player1.size/2 - (bomb.x + bomb.size/2)) < (player1.size + bomb.size)/2 &&
                Math.abs(player1.y + player1.size/2 - (bomb.y + bomb.size/2)) < (player1.size + bomb.size)/2) {
                bomb.exploding = true;
                gameState.gameOver = true;
                gameState.winner = 'blue';
                scores.blue++;
                return true;
            }
            
            // Check if player2 hit the bomb
            if (Math.abs(player2.x + player2.size/2 - (bomb.x + bomb.size/2)) < (player2.size + bomb.size)/2 &&
                Math.abs(player2.y + player2.size/2 - (bomb.y + bomb.size/2)) < (player2.size + bomb.size)/2) {
                bomb.exploding = true;
                gameState.gameOver = true;
                gameState.winner = 'red';
                scores.red++;
                return true;
            }
            
            return false;
        }

        // Update game loop
        function gameLoop() {
            // Draw rainbow checkered background
            drawBackground();

            if (gameState.gameOver) {
                // Update death message based on how the player died
                const deathMessage = document.getElementById('deathMessage');
                if (bomb.exploding) {
                    deathMessage.textContent = `${gameState.winner === 'red' ? 'BLUE' : 'RED'} EXPLODED!`;
                } else {
                    deathMessage.textContent = `YIKES, ${gameState.winner === 'red' ? 'BLUE' : 'RED'} died!`;
                }
                
                // Draw the bomb explosion first if it's active
                if (bomb.active && bomb.exploding) {
                    drawBomb();
                }
                
                // Update victory animation
                if (victoryAnimation.progress < 100) {
                    victoryAnimation.progress += victoryAnimation.speed;
                }
                
                // Calculate bar height with ease-in-out effect
                const easeInOut = (t) => {
                    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
                };

                const animationProgress = easeInOut(victoryAnimation.progress / 100);
                const barHeight = Math.min(victoryAnimation.maxHeight, 
                                          (victoryAnimation.maxHeight * animationProgress));
                
                // Save context for rotation
                ctx.save();
                
                // Draw top bar with rotation - moved up with offset
                ctx.save(); // Save context for top bar
                ctx.translate(canvas.width / 2, -victoryAnimation.topOffset);
                ctx.rotate(victoryAnimation.angle * Math.PI / 180);
                ctx.translate(-canvas.width / 2, victoryAnimation.topOffset);
                
                // Add drop shadow to the bar
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 8;
                ctx.shadowOffsetY = 8;
                
                // Create more complex gradient for top bar with additional color stops
                const topGradient = ctx.createLinearGradient(0, -victoryAnimation.topOffset, 0, barHeight);
                topGradient.addColorStop(0, gameState.winner);
                topGradient.addColorStop(0.2, shadeColor(gameState.winner, 70)); // Very light shade
                topGradient.addColorStop(0.4, shadeColor(gameState.winner, 30)); // Light shade
                topGradient.addColorStop(0.6, gameState.winner); // Original color
                topGradient.addColorStop(0.8, shadeColor(gameState.winner, -30)); // Dark shade
                topGradient.addColorStop(1, shadeColor(gameState.winner, -70)); // Very dark shade
                
                ctx.fillStyle = topGradient;
                // Make the bar wider and taller to ensure it touches the bottom
                ctx.fillRect(-canvas.width * 2, -victoryAnimation.topOffset, canvas.width * 5, barHeight);
                ctx.restore(); // Restore context after top bar
                
                // Save context for bottom bar rotation
                ctx.save();
                // Draw bottom bar with rotation (same angle as top) - moved down with offset
                ctx.translate(canvas.width / 2, canvas.height + victoryAnimation.bottomOffset);
                ctx.rotate(victoryAnimation.angle * Math.PI / 180);
                ctx.translate(-canvas.width / 2, -(canvas.height + victoryAnimation.bottomOffset));
                
                // Add drop shadow to the bottom bar
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 8;
                ctx.shadowOffsetY = 8;
                
                // Create more complex gradient for bottom bar with additional color stops
                const bottomGradient = ctx.createLinearGradient(0, canvas.height + victoryAnimation.bottomOffset - barHeight, 0, canvas.height + victoryAnimation.bottomOffset);
                bottomGradient.addColorStop(0, shadeColor(gameState.winner, -70)); // Very dark shade
                bottomGradient.addColorStop(0.2, shadeColor(gameState.winner, -30)); // Dark shade
                bottomGradient.addColorStop(0.4, gameState.winner); // Original color
                bottomGradient.addColorStop(0.6, shadeColor(gameState.winner, 30)); // Light shade
                bottomGradient.addColorStop(0.8, shadeColor(gameState.winner, 70)); // Very light shade
                bottomGradient.addColorStop(1, gameState.winner);
                
                ctx.fillStyle = bottomGradient;
                // Make the bar wider and position it to ensure it touches the bottom
                ctx.fillRect(-canvas.width * 2, canvas.height + victoryAnimation.bottomOffset - barHeight, canvas.width * 5, barHeight);
                ctx.restore(); // Restore context after bottom bar
                
                // Reset transformation
                ctx.restore();
                
                // Draw victory text with pulsing animation
                const victoryPulseFactor = 1 + 0.05 * Math.sin(Date.now() / 2000); // Slower and subtler pulse

                // Save context for scaling
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.scale(victoryPulseFactor, victoryPulseFactor);
                ctx.translate(-canvas.width / 2, -canvas.height / 2);

                ctx.font = 'bold 72px "Nunito", sans-serif';
                ctx.textAlign = 'center';

                // Set shadow
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 4;

                // Draw text with stroke
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 8;
                ctx.strokeText(
                    `${gameState.winner.toUpperCase()} WINS!`, 
                    canvas.width / 2, 
                    canvas.height / 2
                );

                // Draw colored fill
                ctx.fillStyle = 'white'; // Change text to white for better contrast with colored bars
                ctx.fillText(
                    `${gameState.winner.toUpperCase()} WINS!`, 
                    canvas.width / 2, 
                    canvas.height / 2
                );

                // Restore context
                ctx.restore();

                // Save context for restart text scaling (different timing)
                ctx.save();
                const restartPulseFactor = 1 + 0.05 * Math.sin(Date.now() / 1500); // Slightly faster pulse

                ctx.translate(canvas.width / 2, canvas.height / 2 + 50);
                ctx.scale(restartPulseFactor, restartPulseFactor);
                ctx.translate(-canvas.width / 2, -(canvas.height / 2 + 50));

                // Reset shadow for restart text but keep some effects
                ctx.shadowColor = 'black';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // Add "Click to restart" text with outline
                ctx.font = '24px "Nunito", sans-serif';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(
                    'Click to restart', 
                    canvas.width / 2, 
                    canvas.height / 2 + 50
                );

                // Fill the text
                ctx.fillStyle = 'white';
                ctx.fillText(
                    'Click to restart', 
                    canvas.width / 2, 
                    canvas.height / 2 + 50
                );

                // Restore context
                ctx.restore();
                
                requestAnimationFrame(gameLoop);
                return;
            }

            // Update snake bodies
            updateSnakeBody(player1);
            updateSnakeBody(player2);

            // Check collisions
            if (checkCollision(player1, player2)) {
                gameState.gameOver = true;
                gameState.winner = 'blue';
                scores.blue++; // Increment blue score
            }
            else if (checkCollision(player2, player1)) {
                gameState.gameOver = true;
                gameState.winner = 'red';
                scores.red++; // Increment red score
            }
            else {
                // Check bomb collision
                checkBombCollision();
            }

            // Draw players
            drawSnake(player1);
            drawSnake(player2);
            
            // Draw bomb
            drawBomb();

            // Always draw scores
            drawScores();

            requestAnimationFrame(gameLoop);
        }

        function updateSnakeBody(player) {
            // Add current position to body
            player.body.unshift({ x: player.x, y: player.y });
            
            // Remove tail if body is too long
            if (player.body.length > player.maxLength) {
                player.body.pop();
            }
        }

        function checkCollision(player, otherPlayer) {
            // Check if player's head hits other player's body
            return otherPlayer.body.some((segment, index) => {
                if (index === 0) return false; // Skip head collision
                return Math.abs(player.x - segment.x) < player.size &&
                       Math.abs(player.y - segment.y) < player.size;
            });
        }

        function resetGame() {
            // Clear the death message
            document.getElementById('deathMessage').textContent = '';
            
            // Reset player 1
            player1.x = 100;
            player1.y = 300;
            player1.body = [];
            player1.direction = { x: 1, y: 0 };

            // Reset player 2
            player2.x = 700;
            player2.y = 300;
            player2.body = [];
            player2.direction = { x: -1, y: 0 };

            // Reset game state
            gameState.gameOver = false;
            gameState.winner = null;

            // Reset bomb
            bomb.active = false;
            bomb.exploding = false;
            setTimeout(placeBomb, 1000); // Place a new bomb after 1 second

            // Reset victory animation
            victoryAnimation.progress = 0;
            
            // Make sure mobile controls still work after reset
            setupMobileControls();
        }

        // Handle keyboard input
        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Movement update function
        function updateMovement() {
            // Player 1 (Red) - Arrow keys
            if (keys['ArrowLeft'] && player1.direction.x !== 1) {
                player1.direction = { x: -1, y: 0 };
            }
            if (keys['ArrowRight'] && player1.direction.x !== -1) {
                player1.direction = { x: 1, y: 0 };
            }
            if (keys['ArrowUp'] && player1.direction.y !== 1) {
                player1.direction = { x: 0, y: -1 };
            }
            if (keys['ArrowDown'] && player1.direction.y !== -1) {
                player1.direction = { x: 0, y: 1 };
            }

            // Player 2 (Blue) - WASD keys
            if (keys['a'] && player2.direction.x !== 1) {
                player2.direction = { x: -1, y: 0 };
            }
            if (keys['d'] && player2.direction.x !== -1) {
                player2.direction = { x: 1, y: 0 };
            }
            if (keys['w'] && player2.direction.y !== 1) {
                player2.direction = { x: 0, y: -1 };
            }
            if (keys['s'] && player2.direction.y !== -1) {
                player2.direction = { x: 0, y: 1 };
            }

            // Update positions
            player1.x += player1.direction.x * player1.speed;
            player1.y += player1.direction.y * player1.speed;
            player2.x += player2.direction.x * player2.speed;
            player2.y += player2.direction.y * player2.speed;

            // Wall collision
            if (player1.x < 0) player1.x = canvas.width - player1.size;
            if (player1.x > canvas.width - player1.size) player1.x = 0;
            if (player1.y < 0) player1.y = canvas.height - player1.size;
            if (player1.y > canvas.height - player1.size) player1.y = 0;

            if (player2.x < 0) player2.x = canvas.width - player2.size;
            if (player2.x > canvas.width - player2.size) player2.x = 0;
            if (player2.y < 0) player2.y = canvas.height - player2.size;
            if (player2.y > canvas.height - player2.size) player2.y = 0;
        }

        // Start the game
        setInterval(updateMovement, 1000/60); // Update movement 60 times per second
        gameLoop();

        // Update style to remove the gray background
        document.body.style.backgroundColor = 'black';

        // Add click handler for restart
        canvas.addEventListener('click', () => {
            if (gameState.gameOver) {
                gameState.gameOver = false;
                gameState.winner = null;
                resetGame();
            }
        });

        // Add touch handler for mobile devices
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault(); // Prevent default touch behavior
            if (gameState.gameOver) {
                gameState.gameOver = false;
                gameState.winner = null;
                resetGame();
            }
        });

        // Place the first bomb when the game starts
        placeBomb();

        // Add this helper function to shade colors
        function shadeColor(color, percent) {
            let R, G, B;
            if (color === 'red') {
                R = 255; G = 0; B = 0;
            } else if (color === 'blue') {
                R = 0; G = 0; B = 255;
            }
            
            R = Math.max(0, Math.min(255, R + percent));
            G = Math.max(0, Math.min(255, G + percent));
            B = Math.max(0, Math.min(255, B + percent));
            
            return `rgb(${R}, ${G}, ${B})`;
        }

        // Add this helper function to convert hex colors to rgba
        function hexToRgba(hex, alpha) {
            // Remove the hash if it exists
            hex = hex.replace('#', '');
            
            // Parse the hex values
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // Return rgba string
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Add this function to handle canvas resizing
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const containerWidth = container.clientWidth;
            
            // If container is smaller than canvas default size
            if (containerWidth < 800) {
                const aspectRatio = canvas.height / canvas.width;
                const newWidth = containerWidth - 24; // Account for border
                const newHeight = newWidth * aspectRatio;
                
                canvas.style.width = newWidth + 'px';
                canvas.style.height = newHeight + 'px';
            } else {
                canvas.style.width = '800px';
                canvas.style.height = '600px';
            }
        }

        // Call resize on load and window resize
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        // Setup mobile controls with proper device detection
        function setupMobileControls() {
            // Simplified detection logic - either touch support OR mobile browser is enough
            // This is more permissive to ensure controls appear on all mobile devices
            const hasTouchSupport = 'ontouchstart' in window || 
                                   navigator.maxTouchPoints > 0 || 
                                   navigator.msMaxTouchPoints > 0;
            
            const isMobileBrowser = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            // Show controls if device has touch support OR is a mobile browser
            if (hasTouchSupport || isMobileBrowser || FORCE_MOBILE_CONTROLS) {
                console.log("Mobile device detected - showing controls");
                
                // Add class to body to trigger CSS rules
                document.body.classList.add('has-touch-support');
                
                // Explicitly show the controls
                document.querySelector('.mobile-controls').style.display = 'flex';
                
                // Get all control buttons
                const controls = document.querySelectorAll('.control-button');
                
                // Remove any existing event listeners (in case of multiple setups)
                controls.forEach(button => {
                    button.replaceWith(button.cloneNode(true));
                });
                
                // Get fresh references after cloning
                const freshControls = document.querySelectorAll('.control-button');
                
                // Add more reliable event handlers for mobile
                freshControls.forEach(button => {
                    console.log(`Setting up button: ${button.id} with direction: ${button.getAttribute('data-direction')}`);
                    
                    // Add both touch and mouse events for better compatibility
                    ['touchstart', 'mousedown'].forEach(eventType => {
                        button.addEventListener(eventType, (e) => {
                            e.preventDefault();
                            const direction = button.getAttribute('data-direction');
                            console.log(`Button pressed: ${button.id}, Direction: ${direction}`);
                            
                            // Add active class for visual feedback
                            button.classList.add('active');
                            
                            // Call the control function
                            handleMobileControl(direction);
                        });
                    });
                    
                    // Add both touch and mouse events for release
                    ['touchend', 'touchcancel', 'mouseup', 'mouseleave'].forEach(eventType => {
                        button.addEventListener(eventType, (e) => {
                            e.preventDefault();
                            button.classList.remove('active');
                        });
                    });
                });
                
                // Add a direct touch handler to document body to ensure touch events work
                document.body.addEventListener('touchmove', (e) => {
                    // Don't prevent default on body to allow scrolling
                    if (e.target.classList.contains('control-button')) {
                        // Only prevent default if touching a control button
                        e.preventDefault();
                    }
                }, { passive: false });
            } else {
                console.log("Desktop device detected - hiding controls");
                // Ensure controls are hidden on desktop
                document.querySelector('.mobile-controls').style.display = 'none';
                document.body.classList.remove('has-touch-support');
            }
            
            // Call orientation handler to set up the correct layout immediately
            handleOrientationChange();
        }

        // Updated orientation change function to respect device type
        function handleOrientationChange() {
            // Only proceed if we're on a touch device
            if (!document.body.classList.contains('has-touch-support')) {
                return;
            }
            
            // Get the current orientation
            const isLandscape = window.matchMedia("(orientation: landscape)").matches;
            const mobileControls = document.querySelector('.mobile-controls');
            
            if (isLandscape) {
                // In landscape mode, position controls to the right
                mobileControls.style.display = 'flex';
                mobileControls.style.flexDirection = 'column';
                
                // Adjust scaling for landscape mode
                document.querySelectorAll('.d-pad').forEach(dpad => {
                    dpad.style.transform = 'scale(0.85)';
                });
            } else {
                // In portrait mode, position controls at the bottom
                mobileControls.style.display = 'flex';
                mobileControls.style.flexDirection = 'row';
                
                // Reset scaling for portrait mode
                document.querySelectorAll('.d-pad').forEach(dpad => {
                    dpad.style.transform = 'scale(1)';
                });
            }
            
            // Force a canvas resize
            resizeCanvas();
        }

        // Re-adding the handleMobileControl function that was removed
        function handleMobileControl(direction) {
            console.log(`Handling direction: ${direction}`);
            
            // Handle player 1 controls
            if (direction === 'up1') {
                player1.direction = { x: 0, y: -1 };
                console.log("Red player: UP");
            } else if (direction === 'down1') {
                player1.direction = { x: 0, y: 1 };
                console.log("Red player: DOWN");
            } else if (direction === 'left1') {
                player1.direction = { x: -1, y: 0 };
                console.log("Red player: LEFT");
            } else if (direction === 'right1') {
                player1.direction = { x: 1, y: 0 };
                console.log("Red player: RIGHT");
            }
            
            // Handle player 2 controls
            if (direction === 'up2') {
                player2.direction = { x: 0, y: -1 };
                console.log("Blue player: UP");
            } else if (direction === 'down2') {
                player2.direction = { x: 0, y: 1 };
                console.log("Blue player: DOWN");
            } else if (direction === 'left2') {
                player2.direction = { x: -1, y: 0 };
                console.log("Blue player: LEFT");
            } else if (direction === 'right2') {
                player2.direction = { x: 1, y: 0 };
                console.log("Blue player: RIGHT");
            }
        }
        
        // Call setup on load
        window.addEventListener('load', setupMobileControls);

        // Add orientation change handling
        window.matchMedia("(orientation: landscape)").addEventListener("change", handleOrientationChange);

        // Call on load to set initial state
        window.addEventListener('load', handleOrientationChange);
        
        // Initialize on DOMContentLoaded to ensure everything is set up properly
        document.addEventListener('DOMContentLoaded', () => {
            // Forcibly show controls for testing if needed
            if (FORCE_MOBILE_CONTROLS) {
                document.body.classList.add('has-touch-support');
                document.querySelector('.mobile-controls').style.display = 'block';
            }
            
            // Make sure mobile detection happens immediately
            setupMobileControls();
            
            // Create dynamic stars for more erratic background movement
            createDynamicStars();
        });
        
        // Function to create dynamic moving stars with random trajectories
        function createDynamicStars() {
            const starContainer = document.querySelector('.star-container');
            const numberOfStars = isMobileDevice() ? 20 : 40; // Fewer stars on mobile for better performance
            
            // Clear any existing stars
            starContainer.innerHTML = '';
            
            for (let i = 0; i < numberOfStars; i++) {
                const star = document.createElement('div');
                star.className = 'small-star';
                
                // Random starting position
                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                
                // Random ending position (for trajectory)
                const endX = (Math.random() - 0.5) * window.innerWidth;
                const endY = (Math.random() - 0.5) * window.innerHeight * 2; // Bias toward vertical movement
                
                // Random duration between 5-15 seconds
                const duration = 5 + Math.random() * 10;
                
                // Random delay
                const delay = Math.random() * 5;
                
                // Random star brightness and size
                const opacity = 0.5 + Math.random() * 0.5;
                const size = 1 + Math.random() * 2;
                
                // Apply styles
                star.style.cssText = `
                    left: ${startX}px;
                    top: ${startY}px;
                    opacity: ${opacity};
                    width: ${size}px;
                    height: ${size}px;
                    --end-x: ${endX}px;
                    --end-y: ${endY}px;
                    animation-duration: ${duration}s;
                    animation-delay: ${delay}s;
                `;
                
                starContainer.appendChild(star);
                
                // Remove and recreate star when animation completes
                setTimeout(() => {
                    if (starContainer.contains(star)) {
                        starContainer.removeChild(star);
                        createNewStar(starContainer);
                    }
                }, (duration + delay) * 1000);
            }
        }
        
        function createNewStar(container) {
            const star = document.createElement('div');
            star.className = 'small-star';
            
            // Start new stars from edges for a flowing effect
            const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let startX, startY;
            
            switch (edge) {
                case 0: // Top
                    startX = Math.random() * window.innerWidth;
                    startY = -5;
                    break;
                case 1: // Right
                    startX = window.innerWidth + 5;
                    startY = Math.random() * window.innerHeight;
                    break;
                case 2: // Bottom
                    startX = Math.random() * window.innerWidth;
                    startY = window.innerHeight + 5;
                    break;
                case 3: // Left
                    startX = -5;
                    startY = Math.random() * window.innerHeight;
                    break;
            }
            
            // Direction is generally towards the opposite side
            const endX = (edge === 1) ? -10 : (edge === 3) ? window.innerWidth + 10 : (Math.random() - 0.5) * window.innerWidth * 2;
            const endY = (edge === 0) ? window.innerHeight + 10 : (edge === 2) ? -10 : (Math.random() - 0.5) * window.innerHeight * 2;
            
            // Random duration between 5-15 seconds
            const duration = 5 + Math.random() * 10;
            
            // Random star brightness and size
            const opacity = 0.5 + Math.random() * 0.5;
            const size = 1 + Math.random() * 2;
            
            // Apply styles
            star.style.cssText = `
                left: ${startX}px;
                top: ${startY}px;
                opacity: ${opacity};
                width: ${size}px;
                height: ${size}px;
                --end-x: ${endX}px;
                --end-y: ${endY}px;
                animation-duration: ${duration}s;
            `;
            
            container.appendChild(star);
            
            // Remove and recreate star when animation completes
            setTimeout(() => {
                if (container.contains(star)) {
                    container.removeChild(star);
                    createNewStar(container);
                }
            }, duration * 1000);
        }
        
        // Helper function to detect mobile
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   (window.innerWidth <= 768);
        }
        
        // Recreate stars on window resize to adjust for new dimensions
        window.addEventListener('resize', debounce(() => {
            createDynamicStars();
        }, 250));
        
        // Simple debounce function to prevent too many star recreations during resize
        function debounce(func, wait) {
            let timeout;
            return function() {
                clearTimeout(timeout);
                timeout = setTimeout(func, wait);
            };
        }
    </script>
    </body>
</html> 